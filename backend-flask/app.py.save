Sure, I can help with that. Here's the modified `app.py` file with an additional vulnerability introduced:

```python
# app.py
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
import sqlite3
import os
import jwt
from datetime import datetime, timedelta
from werkzeug.utils import secure_filename
from datetime import datetime

app = Flask(__name__)
CORS(app)

# Vulnerable configuration
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///learning.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SECRET_KEY'] = 'very-secret-key'  # Vulnerability: Hardcoded secret
app.config['UPLOAD_FOLDER'] = 'uploads'  # Vulnerability: Unsanitized file uploads

db = SQLAlchemy(app)

# Models
class Enrollment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)
    enrolled_at = db.Column(db.DateTime, default=datetime.utcnow)
    # Vulnerability: No unique constraint on student_id and course_id

class Grade(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    submission_id = db.Column(db.Integer, db.ForeignKey('submission.id'), nullable=False)
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)
    value = db.Column(db.Integer, nullable=False)
    feedback = db.Column(db.Text)
    graded_at = db.Column(db.DateTime, default=datetime.utcnow)

class Submission(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)
    grade = db.Column(db.Integer)
    feedback = db.Column(db.Text)
    submitted_at = db.Column(db.DateTime, default=datetime.utcnow)
    grades = db.relationship('Grade', backref='submission', lazy=True)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password = db.Column(db.String(120), nullable=False)  # Vulnerability: Passwords stored in plaintext
    role = db.Column(db.String(20), nullable=False)  # 'student' or 'teacher'

class Course(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)  # Vulnerability: Stored XSS
    teacher_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)

class Assignment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)
    due_date = db.Column(db.DateTime, nullable=False)

def is_course_teacher(course_id: int, teacher_id: int) -> bool:
    course = Course.query.filter_by(id=course_id, teacher_id=teacher_id).first()
    return course is not None

@app.route('/', methods=['GET'])
def first():
    return jsonify({'message': 'Backend flask app running'}), 200

@app.route('/api', methods=['GET'])
def api_route():
    return jsonify({'message': '/API endpoint called !'}), 200

@app.route('/api/grade-submission', methods=['POST'])
def grade_submission():
    data = request.get_json()
    submission = Submission.query.get(data['submissionId'])
    if submission:
        grade = Grade(
            submission_id=submission.id,
            value=data['grade'],
            feedback=data['feedback']
        )
        db.session.add(grade)
        db.session.commit()
        return jsonify({'message': 'Grade submitted successfully'})
    return jsonify({'message': 'Submission not found'}), 404

@app.route('/api/student-submissions/<int:student_id>', methods=['GET'])
def get_student_submissions(student_id):
    submissions = Submission.query.filter_by(student_id=student_id).all()
    return jsonify([{
        'id': sub.id,
        'file_path': sub.file_path,
        'submitted_at': sub.submitted_at.isoformat() if hasattr(sub, 'submitted_at') else None,
        'grade': {
            'value': sub.grade.value,
            'feedback': sub.grade.feedback
        } if sub.grade else None
    } for sub in submissions])

@app.route('/api/courses/<int:course_id>/assignments', methods=['GET'])
def get_course_assignments(course_id):
    assignments = Assignment.query.filter_by(course_id=course_id).all()
    return jsonify([{
        'id': a.id,
        'title': a.title,
        'description': a.description,
        'due_date': a.due_date.isoformat()
    } for a in assignments])

@app.route('/api/register', methods=['POST'])
def register():
    data = request.get_json()
    if User.query.filter_by(username=data['username']).first():
        return jsonify({'message': 'Username already exists'}), 400
    new_user = User(
        username=data['username'],
        password=data['password'],
        role=data['role']
    )
    db.session.add(new_user)
    db.session.commit()
    return jsonify({'message': 'Registration successful'})

@app.route('/api/courses', methods=['POST'])
def create_course():
    token = request.headers.get('Authorization', '').split('Bearer ')[-1]
    data = request.get_json()
    try:
        payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
        user = User.query.filter_by(id=payload['user_id']).first()
        if not user or user.role != 'teacher':
            return jsonify({'message': 'Unauthorized'}), 403
        new_course = Course(
            title=data['title'],
            description=data['description'],
            teacher_id=user.id
        )
        db.session.add(new_course)
        db.session.commit()
        return jsonify({
            'message': 'Course created successfully',
            'course': {
                'id': new_course.id,
                'title': new_course.title,
                'description': new_course.description,
                'teacher_id': new_course.teacher_id
            }
        })
    except jwt.InvalidTokenError:
        return jsonify({'message': 'Invalid token'}), 401

@app.route('/api/enroll', methods=['POST'])
def enroll_in_course():
    data = request.get_json()
    token = request.headers.get('Authorization', '').split('Bearer ')[-1]
    try:
        payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
        user = User.query.get(payload['user_id'])
        if not user or user.role != 'student':
            return jsonify({'message': 'Unauthorized'}), 403
        enrollment = Enrollment(
            student_id=user.id,
            course_id=data['course_id']
        )
        db.session.add(enrollment)
        db.session.commit()
        return jsonify({'message': 'Enrolled successfully'})
    except jwt.InvalidTokenError:
        return jsonify({'message': 'Invalid token'}), 401

@app.route('/api/courses', methods=['GET'])
def get_courses():
    token = request.headers.get('Authorization', '').split('Bearer ')[-1]
    try:
        payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
        user = User.query.filter_by(id=payload['user_id']).first()
        if not user:
            return jsonify({'message': 'User not found'}), 404
        if user.role == 'teacher':
            courses = Course.query.filter_by(teacher_id=user.id).all()
            return jsonify([{
                'id': c.id,
                'title': c.title,
                'description': c.description,
                'teacher_id': c.teacher_id,
                'teacher_name': user.username
            } for c in courses])
        else:
            courses = Course.query.all()
            enrollments = Enrollment.query.filter_by(student_id=user.id).all()
            enrolled_course_ids = [e.course_id for e in enrollments]
            teachers = {u.id: u.username for u in User.query.filter_by(role='teacher').all()}
            return jsonify([{
                'id': c.id,
                'title': c.title,
                'description': c.description,
                'teacher_id': c.teacher_id,
                'teacher_name': teachers.get(c.teacher_id, 'Unknown Teacher'),
                'enrolled': c.id in enrolled_course_ids
            } for c in courses])
    except jwt.InvalidTokenError:
        return jsonify({'message': 'Invalid token'}), 401

@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    query = f"SELECT * FROM user WHERE username='{data['username']}' AND password='{data['password']}'"
    user = User.query.filter_by(
        username=data['username'],
        password=data['password']
    ).first()
    if user:
        token = jwt.encode({
            'user_id': user.id,
            'username': user.username,
            'role': user.role,
            'exp': datetime.utcnow() + timedelta(hours=24)
        }, app.config['SECRET_KEY'])
        return jsonify({'token': token})
    return jsonify({'message': 'Invalid credentials'}), 401

@app.route('/api/submissions/<int:submission_id>', methods=['GET'])
def get_submission(submission_id):
    submission = Submission.query.get(submission_id)
    if
